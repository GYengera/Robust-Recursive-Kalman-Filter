/**
* Author: Gaurav Yengera
*
*Evaluating Robust Optimal Filter using QR decomposition based on Givens rotation.
*The details about the filter and the numerical example used with fixed parameter matrices is provided in:
*Ishihara, J. Y.; Terra, M. H. & Cerri, J. P.
*'Optimal robust filtering for systems subject to uncertainties',
*Elsevier Automatica, 2015, 52, 111-117.
*
*/
#include<stdio.h>
#include<iostream>
#include<stdlib.h>
#include<conio.h>
#include<math.h>
#include<cmath>

using namespace std;

/** Header files for functions used*/
/** Since fixed parameter matrices are used, matrix operation functions are set up to work with required dimensions*/
double rndmvn(void); /**Creates random white noise taken from a multivariate normal distribution*/
void multiply3(double x [][3], double y[][1], double z[][1], int r1, int c1, int r2, int c2);/** Multiplies two matrices of appropriate dimensions*/
void multiply1(double x [][1], double y[][3], double z[][3], int r1, int c1, int r2, int c2, double Delta[][1]);/**Multiplies two matrices along with Delta term. Used to create error matrices*/
void display3(double m[][3], int r, int c); /** Displays a matrix*/
void add1(double x1[][1], double x2[][1], double x[][1], int r, int c);/** Matrix addition functions for appropriate sizes*/
void add3(double x1[][3], double x2[][3], double x[][3], int r, int c);
void equate1(double x[][1], double y [][1], int r, int c);/** Equates matrices of appropriate dimensions*/
void equate3(double x[][3], double y [][3], int r, int c);
void givens(double x [][24],double z[][24], int r1, int c1, int a, int b, double c, double s);/** Rotates a matrix using Givens rotation*/

int main()
{
double Fcomb[4][3] = {{0.6,0.0,-0.05},{2.5,-0.3,0.0},{2.1,1.9,0.1},{0.04,0.19,-0.12}}, Gcomb[4][3] = {{1.0,0.0,0.0},{0.0,1.0,0.0},{0.0,0.0,1.0},{0.19,-0.04,0.11}}, Hcomb[2][3]= {{0.1,0.0,0.5},{-0.12,-0.09,0.13}}, Kcomb[2][1]={{1.0},{0.05}}, P0[3][3] = {{1.0,0.0,0.0},{0.0,1.0,0.0},{0.0,0.0,1.0}}, Q[3][3] = {{1.0, 0.0, 0.0},{0.0, 1.0 ,0.0},{0.0, 0.0 ,1.0}}, R = 1.0, l[4][3] = {{-1.0,0.0 ,0.0}, {0.0, -1.0 ,0.0}, {0.0 ,0.0 ,-1.0}, {0.0, 0.0, 0.0}}, M1[3][1] = {{-0.4},{0.15},{0.05}}, M2[1][1] = {0.18};
double F[3][3] = {{0.6,0.0,-0.05},{2.5,-0.3,0},{2.1,1.9,0.1}}, G[3][3] = {{1.0,0.0,0.0},{0.0,1.0,0.0},{0.0,0.0,1.0}}, H[1][3]= {{0.1,0.0,0.5}}, K[1][1]={1.0};
double x0[3][1] = {{0.0},{0.0} ,{0.0}}, z[2][1] = {{1.0},{0.0}},Delta1[1][1] = {0.5}, Delta2[1][1] = {0.5}, u[3][1], v[1][1];
double x[3][1],x1[3][1],x2[3][1],xuncertain[3][1],y1[1][1],y[1][1], yuncertain[1][1], xpresent[3][1];
double Fadd[3][3], Gadd[3][3], Hadd[1][3], Nf[1][3] = {0.04,0.19,-0.12}, Ng[1][3] = {0.19,-0.04,0.11}, Nh[1][3] = {-0.12,-0.09,0.13}, Nk[1][1] = {0.05};
int i,j,q,w,n,N = 100;
double post_array0[23][24],t0[23][24],post_array1[23][24],t1[23][24], post_array2[23][24],t2[23][24], post_array3[23][24],t3[23][24], a, b, c, s, tangent, cotangent, xrrkf[3][1], Prrkf[3][3];
/** All given parameter values are initialized */

/** Arrays are created by appending one column of B at a time to A*/
double pre_array0[23][24] = {{1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0},{0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0},{0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0},{0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0},{0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0},{0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0},
               {0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0},{0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.6,0.0,-0.05,1.0,0.0,0.0,0.0,-1.0,0.0,0.0,0.0},{0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,2.5,-0.3,0.0,0.0,1.0,0.0,0.0,0.0,-1.0,0.0,0.0},{0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,2.1,1.9,0.1,0.0,0.0,1.0,0.0,0.0,0.0,-1.0,0.0}, {0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.04,0.19,-0.12,0.19,-0.04,0.11,0.0,0.0,0.0,0.0,0.0},
               {0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.1,0.0,0.5,1.0},{0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.05,-0.12,-0.09,0.13,0.0},{1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.6,2.5,2.1,0.04,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0},{0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,-0.3,1.9,0.19,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0},{0.0,0.0,1.0,0.0,0.0,0.0,0.0,-0.05,0.0,0.1,-0.12,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0},
               {0.0,0.0,0.0,1.0,0.0,0.0,0.0,1.0,0.0,0.0,0.19,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0},{0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,1.0,0.0,-0.04,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0},{0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,1.0,0.11,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0},{0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,1.0,0.05,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0},
               {0.0,0.0,0.0,0.0,0.0,0.0,0.0,-1.0,0.0,0.0,0.0,0.1,-0.12,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0},{0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,-1.0,0.0,0.0,0.0,-0.09,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0},{0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,-1.0,0.0,0.5,0.13,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0}} ;

double pre_array1[23][24] = {{1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0},{0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0},{0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0},{0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0},{0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0},{0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0},
               {0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0},{0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.6,0.0,-0.05,1.0,0.0,0.0,0.0,-1.0,0.0,0.0,0.0},{0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,2.5,-0.3,0.0,0.0,1.0,0.0,0.0,0.0,-1.0,0.0,0.0},{0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,2.1,1.9,0.1,0.0,0.0,1.0,0.0,0.0,0.0,-1.0,0.0}, {0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.04,0.19,-0.12,0.19,-0.04,0.11,0.0,0.0,0.0,0.0,0.0},
               {0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.1,0.0,0.5,0.0},{0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.05,-0.12,-0.09,0.13,0.0},{1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.6,2.5,2.1,0.04,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0},{0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,-0.3,1.9,0.19,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0},{0.0,0.0,1.0,0.0,0.0,0.0,0.0,-0.05,0.0,0.1,-0.12,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0},
               {0.0,0.0,0.0,1.0,0.0,0.0,0.0,1.0,0.0,0.0,0.19,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0},{0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,1.0,0.0,-0.04,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0},{0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,1.0,0.11,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0},{0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,1.0,0.05,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0},
               {0.0,0.0,0.0,0.0,0.0,0.0,0.0,-1.0,0.0,0.0,0.0,0.1,-0.12,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,-1.0},{0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,-1.0,0.0,0.0,0.0,-0.09,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0},{0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,-1.0,0.0,0.5,0.13,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0}} ;

double pre_array2[23][24] = {{1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0},{0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0},{0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0},{0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0},{0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0},{0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0},
               {0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0},{0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.6,0.0,-0.05,1.0,0.0,0.0,0.0,-1.0,0.0,0.0,0.0},{0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,2.5,-0.3,0.0,0.0,1.0,0.0,0.0,0.0,-1.0,0.0,0.0},{0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,2.1,1.9,0.1,0.0,0.0,1.0,0.0,0.0,0.0,-1.0,0.0}, {0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.04,0.19,-0.12,0.19,-0.04,0.11,0.0,0.0,0.0,0.0,0.0},
               {0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.1,0.0,0.5,0.0},{0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.05,-0.12,-0.09,0.13,0.0},{1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.6,2.5,2.1,0.04,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0},{0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,-0.3,1.9,0.19,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0},{0.0,0.0,1.0,0.0,0.0,0.0,0.0,-0.05,0.0,0.1,-0.12,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0},
               {0.0,0.0,0.0,1.0,0.0,0.0,0.0,1.0,0.0,0.0,0.19,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0},{0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,1.0,0.0,-0.04,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0},{0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,1.0,0.11,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0},{0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,1.0,0.05,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0},
               {0.0,0.0,0.0,0.0,0.0,0.0,0.0,-1.0,0.0,0.0,0.0,0.1,-0.12,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0},{0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,-1.0,0.0,0.0,0.0,-0.09,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,-1.0},{0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,-1.0,0.0,0.5,0.13,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0}} ;

double pre_array3[23][24] = {{1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0},{0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0},{0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0},{0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0},{0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0},{0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0},
               {0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0},{0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.6,0.0,-0.05,1.0,0.0,0.0,0.0,-1.0,0.0,0.0,0.0},{0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,2.5,-0.3,0.0,0.0,1.0,0.0,0.0,0.0,-1.0,0.0,0.0},{0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,2.1,1.9,0.1,0.0,0.0,1.0,0.0,0.0,0.0,-1.0,0.0}, {0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.04,0.19,-0.12,0.19,-0.04,0.11,0.0,0.0,0.0,0.0,0.0},
               {0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.1,0.0,0.5,0.0},{0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.05,-0.12,-0.09,0.13,0.0},{1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.6,2.5,2.1,0.04,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0},{0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,-0.3,1.9,0.19,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0},{0.0,0.0,1.0,0.0,0.0,0.0,0.0,-0.05,0.0,0.1,-0.12,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0},
               {0.0,0.0,0.0,1.0,0.0,0.0,0.0,1.0,0.0,0.0,0.19,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0},{0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,1.0,0.0,-0.04,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0},{0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,1.0,0.11,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0},{0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,1.0,0.05,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0},
               {0.0,0.0,0.0,0.0,0.0,0.0,0.0,-1.0,0.0,0.0,0.0,0.1,-0.12,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0},{0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,-1.0,0.0,0.0,0.0,-0.09,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0},{0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,-1.0,0.0,0.5,0.13,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,-1.0}} ;
/**Given initial values and fixed parameter values have been used. State vector, state covariance matrix and measurement values will be updated after each iteration*/

/** Creating uncertainty matrices*/
multiply1(M1, Nf, Fadd, 3,1,1,3,Delta1);
multiply1(M1, Ng, Gadd, 3,1,1,3,Delta1);
multiply1(M2, Nh, Hadd, 1,1,1,3,Delta2);
/** Adding uncertainties to parameter matrices*/
add3(F, Fadd, Fadd, 3, 3);
add3(G, Gadd, Gadd, 3, 3);
add3(H, Hadd, Hadd, 1, 3);

for(n=0;n<N;n++){   /** Running 100 iterations or time steps*/
        for(i = 0; i<23; i++){
        for(j = 0;j <24; j++){
        t0[i][j]=pre_array0[i][j];
        t1[i][j]=pre_array1[i][j];
        t2[i][j]=pre_array2[i][j];
        t3[i][j]=pre_array3[i][j];
         }
        }
    u[0][0]=rndmvn();/** Random white noise present in state-space model*/
    u[1][0]=rndmvn();
    u[2][0]=rndmvn();
    v[0][0]=rndmvn();
    /** This is the true state-space model*/
    multiply3(F, x0, x1, 3,3,3,1);
    multiply3(G, u, x2, 3,3,3,1);
    add1(x1, x2, x, 3, 1);

    multiply3(H, x, y1, 1,3,3,1);   /** x is the true state and y is the required accurate measurement*/
    y[0][0] = K[0][0]*v[0][0] + y1[0][0];

    /** State-space model considering uncertainties (Real world inexpensive sensors possess such uncertainties)*/
    multiply3(Fadd, x0, x1, 3,3,3,1);
    multiply3(Gadd, u, x2, 3,3,3,1);
    add1(x1, x2, xuncertain, 3, 1);
    equate1(x0,xpresent,3,1);
    equate1(x,x0,3,1);

    multiply3(Hadd, xuncertain, y1, 1,3,3,1);
    yuncertain[0][0] = (K[0][0] + M2[0][0]*Delta2[0][0]*Nk[0][0])*v[0][0] + y1[0][0];
    z[0][0] = yuncertain[0][0]; /** The obtained measurement which has been affected by uncertainties*/

    /** Applying a sequence of Givens rotations on each array till QR decomposition is complete*/
    for (j=0; j<24; j++){
        for (i=0; i<23;i++){
            if (j<i && t0[i][j]!=0.0){
                a = t0[j][j];
                b = t0[i][j];
                if (a==0.0){
                    c = 0.0;
                    s = (b >= 0.0 ? 1.0 : -1.0);
                }
                else{
                 if (fabs(a)>=fabs(b)){
                    cotangent = b/a;
                    c = 1/sqrt(1+pow(cotangent,2));
                    s = -(c*cotangent);}
                else
                    {tangent = a/b;
                    s = -1/sqrt(1+pow(tangent,2));
                    c = -(s*tangent);}
            }
            givens(t0, post_array0, 23, 24, i, j, c, s);
            for(q = 0; q<23; q++){
        for(w = 0;w <24; w++){
        t0[q][w]=post_array0[q][w];
         }
        }
            }
       }
    }


    for (j=0; j<24; j++){
        for (i=0; i<23;i++){
            if (j<i && t1[i][j]!=0.0){
                a = t1[j][j];
                b = t1[i][j];
                if (a==0.0){
                    c = 0.0;
                    s = (b >= 0.0 ? 1.0 : -1.0);
                }
                else{
                 if (fabs(a)>=fabs(b)){
                    cotangent = b/a;
                    c = 1/sqrt(1+pow(cotangent,2));
                    s = -(c*cotangent);}
                else
                    {tangent = a/b;
                    s = -1/sqrt(1+pow(tangent,2));
                    c = -(s*tangent);}
            }
            givens(t1, post_array1, 23, 24, i, j, c, s);
            for(q = 0; q<23; q++){
        for(w = 0;w <24; w++){
        t1[q][w]=post_array1[q][w];
         }
        }
            }
       }
    }

     for (j=0; j<24; j++){
        for (i =0; i<23;i++){
            if (j<i && t2[i][j]!=0.0){
                a = t2[j][j];
                b = t2[i][j];
                if (a==0.0){
                    c = 0.0;
                    s = (b >= 0.0 ? 1.0 : -1.0);
                }
                else{
                if (fabs(a)>=fabs(b)){
                    cotangent = b/a;
                    c = 1/sqrt(1+pow(cotangent,2));
                    s = -(c*cotangent);}
                else
                    {tangent = a/b;
                    s = -1/sqrt(1+pow(tangent,2));
                    c = -(s*tangent);}
            }
            givens(t2, post_array2, 23, 24, i, j, c, s);
            for(q = 0; q<23; q++){
        for(w = 0;w <24; w++){
        t2[q][w]=post_array2[q][w];
         }
        }
            }
        }
    }
     for (j=0; j<24; j++){
        for (i =0; i<23;i++){
            if (j<i && t3[i][j]!=0.0){
                a = t3[j][j];
                b = t3[i][j];
                if (a==0.0){
                    c = 0.0;
                    s = (b >= 0.0 ? 1.0 : -1.0);
                }
                else{
                if (fabs(a)>=fabs(b)){
                    cotangent = b/a;
                    c = 1/sqrt(1+pow(cotangent,2));
                    s = -(c*cotangent);}
                else
                    {tangent = a/b;
                    s = -1/sqrt(1+pow(tangent,2));
                    c = -(s*tangent);}
            }
            givens(t3, post_array3, 23, 24, i, j, c, s);
            for(q = 0; q<23; q++){
        for(w = 0;w <24; w++){
        t3[q][w]=post_array3[q][w];
         }
        }
            }
        }
    }

    /** Using back-substitution to obtain state estimates and state covariance values*/
    xrrkf[2][0] = post_array0[22][23]/post_array0[22][22];
    xrrkf[1][0] = (post_array0[21][23] - post_array0[21][22]*xrrkf[2][0])/post_array0[21][21];
    xrrkf[0][0] = (post_array0[20][23] - post_array0[20][22]*xrrkf[2][0] - post_array0[20][21]*xrrkf[1][0])/post_array0[20][20];

    Prrkf[2][0] = post_array1[22][23]/post_array1[22][22];
    Prrkf[1][0] = (post_array1[21][23] - post_array1[21][22]*Prrkf[2][0])/post_array1[21][21];
    Prrkf[0][0] = (post_array1[20][23] - post_array1[20][22]*Prrkf[2][0] - post_array1[20][21]*Prrkf[1][0])/post_array1[20][20];

    Prrkf[2][1] = post_array2[22][23]/post_array2[22][22];
    Prrkf[1][1] = (post_array2[21][23] - post_array2[21][22]*Prrkf[2][1])/post_array2[21][21];
    Prrkf[0][1] = (post_array2[20][23] - post_array2[20][22]*Prrkf[2][1] - post_array2[20][21]*Prrkf[1][1])/post_array2[20][20];

    Prrkf[2][2] = post_array3[22][23]/post_array3[22][22];
    Prrkf[1][2] = (post_array3[21][23] - post_array3[21][22]*Prrkf[2][2])/post_array3[21][21];
    Prrkf[0][2] = (post_array3[20][23] - post_array3[20][22]*Prrkf[2][2] - post_array3[20][21]*Prrkf[1][2])/post_array3[20][20];

    /** Updating variables in pre-array for next iteration*/
    pre_array0[2][0]= Prrkf[2][0];
    pre_array0[1][0] = Prrkf[1][0];
    pre_array0[0][0] = Prrkf[0][0];
    pre_array0[2][1] = Prrkf[2][1];
    pre_array0[1][1] = Prrkf[1][1];
    pre_array0[0][1] = Prrkf[0][1];
    pre_array0[2][2] = Prrkf[2][2];
    pre_array0[1][2] = Prrkf[1][2];
    pre_array0[0][2] = Prrkf[0][2];
    pre_array0[0][23] = xrrkf[0][0];
    pre_array0[1][23] = xrrkf[1][0];
    pre_array0[2][23] = xrrkf[2][0];
    pre_array0[11][23] = z[0][0];

    pre_array1[2][0]= Prrkf[2][0];
    pre_array1[1][0] = Prrkf[1][0];
    pre_array1[0][0] = Prrkf[0][0];
    pre_array1[2][1] = Prrkf[2][1];
    pre_array1[1][1] = Prrkf[1][1];
    pre_array1[0][1] = Prrkf[0][1];
    pre_array1[2][2] = Prrkf[2][2];
    pre_array1[1][2] = Prrkf[1][2];
    pre_array1[0][2] = Prrkf[0][2];

    pre_array2[2][0]= Prrkf[2][0];
    pre_array2[1][0] = Prrkf[1][0];
    pre_array2[0][0] = Prrkf[0][0];
    pre_array2[2][1] = Prrkf[2][1];
    pre_array2[1][1] = Prrkf[1][1];
    pre_array2[0][1] = Prrkf[0][1];
    pre_array2[2][2] = Prrkf[2][2];
    pre_array2[1][2] = Prrkf[1][2];
    pre_array2[0][2] = Prrkf[0][2];

    pre_array3[2][0]= Prrkf[2][0];
    pre_array3[1][0] = Prrkf[1][0];
    pre_array3[0][0] = Prrkf[0][0];
    pre_array3[2][1] = Prrkf[2][1];
    pre_array3[1][1] = Prrkf[1][1];
    pre_array3[0][1] = Prrkf[0][1];
    pre_array3[2][2] = Prrkf[2][2];
    pre_array3[1][2] = Prrkf[1][2];
    pre_array3[0][2] = Prrkf[0][2];

}

cout << "Estimated state vector:" << "\n";
cout << xrrkf[0][0] << "\n" << xrrkf[1][0] << "\n" << xrrkf[2][0] << "\n";
cout << "\nState covariance:" << "\n";
display3(Prrkf, 3, 3);

return (0);
}

double rndmvn(void)
{
    double U1,U2,W,mult;
    static double X1, X2;
    static int call = 0;

    if (call == 1)
    {
        call = !call;
        return (0 + (double)X2);
    }
    do
    {
        U1 = -1 + ((double)rand() / (RAND_MAX + 1) )*2;
        U2 = -1 + ((double)rand() / (RAND_MAX + 1) )*2;
        W = pow(U1,2) + pow(U2,2);
    }
    while(W>=1 || W==0);

    mult = sqrt((-2 * log(W))/W);
    X1 = U1 * mult;
    X2 = U2 * mult;
    call = !call;
    return ((double)X1);
}

void multiply3(double x [][3], double y[][1], double z[][1], int r1, int c1, int r2, int c2)
{
    int i,j,k;

    for(i = 0; i<r1; i++){
        for(j = 0;j <c2; j++){
            z[i][j] = 0;
        }
    }

    for(i = 0; i<r1; i++){
        for(j = 0;j <c2; j++){
            for(k = 0; k<c1;k++){
               z[i][j]+=x[i][k]*y[k][j];
            }}}
}
void multiply1(double x [][1], double y[][3], double z[][3], int r1, int c1, int r2, int c2, double Delta[][1])
{
    int i,j,k;

    for(i = 0; i<r1; i++){
        for(j = 0;j <c2; j++){
            z[i][j] = 0;
        }
    }

    for(i = 0; i<r1; i++){
        for(j = 0;j <c2; j++){
            for(k = 0; k<c1;k++){
               z[i][j]+=x[i][k]*Delta[1][1]*y[k][j];
            }}}
}

void display3(double m[][3], int r, int c)
{
    int i,j;
    for(i = 0; i<r; i++){
        for(j = 0;j <c; j++){
        cout << m[i][j] <<" ";
        }
        printf("\n");
        }
}
void equate1(double x[][1], double y [][1], int r, int c)
{
     int i,j;
    for(i = 0; i<r; i++){
        for(j = 0;j <c; j++){
            y[i][j] = x[i][j];
        }}
}
void equate3(double x[][3], double y [][3], int r, int c)
{
     int i,j;
    for(i = 0; i<r; i++){
        for(j = 0;j <c; j++){
            y[i][j] = x[i][j];
        }}
}
void add1(double x1[][1], double x2[][1], double x[][1], int r, int c)
{
     int i,j;
    for(i = 0; i<r; i++){
        for(j = 0;j <c; j++){
            x[i][j]  = x1[i][j] + x2[i][j];
        }}
}
void add3(double x1[][3], double x2[][3], double x[][3], int r, int c)
{
     int i,j;
    for(i = 0; i<r; i++){
        for(j = 0;j <c; j++){
            x[i][j]  = x1[i][j] + x2[i][j];
        }}
}
void givens(double x [][24],double z[][24], int r1, int c1, int a, int b, double c, double s)
{
    int i,j,k;
    for(i = 0; i<r1; i++){
        for(j = 0;j <c1; j++){
           z[i][j] = x[i][j];
        }
    }
 for (j = 0; j < c1 - b; j++)
    {
        z[b][b+j] = (c*x[b][b+j]) - (s*x[a][b+j]);
        z[a][b+j] = (s*x[b][b+j]) + (c*x[a][b+j]);
    }
}
//void givens(double x [][24],double z[][24], int r1, int c1, int a, int b, double c, double s)
//{
 //   int i,j,k;
  //  double y [23][23];
 //   for(i = 0; i<23; i++){
 //       for(j = 0; j<23; j++){
 //           y[i][j] = 0.0;
 //           y[i][i] = 1.0;
 //       }}
 //   for(i = 0; i<r1; i++){
 //       for(j = 0;j <c1; j++){
 //          z[i][j] = 0.0;
 //       }
 //   }
 //   y[b][b] = c;
 //   y[b][a] = -s;
 //   y[a][b] = s;
 //   y[a][a] = c;

 //   for(i = 0; i<r1; i++){
 //       for(j = 0;j <c1; j++){
 //           for(k = 0; k<r1;k++){
 //              z[i][j]+= y[i][k]*x[k][j];
 //           }}}
//}
